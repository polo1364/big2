<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>大老二 — 系列戰 v10（修復可遊玩＋錯誤顯示）</title>
<style>
:root{
  --card-w:56px;--card-h:80px;--gap:6px;--panel-w:min(92vw,980px);
  --pile-w:42px;--pile-h:58px;--primary:#3aa7ff;--primary-dark:#1c86d8;
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{margin:0;background:radial-gradient(#162333,#0b121a);color:#e6eef6;font-family:"Microsoft JhengHei",system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;user-select:none;overflow:hidden}
h1{margin:10px 0 6px;font-weight:800;letter-spacing:.5px;font-size:18px}
#stage{position:relative;width:100%;height:100dvh;display:grid;grid-template-rows:auto 1fr auto}
.topbar{display:flex;justify-content:center;align-items:center;padding:6px 10px}
#resetScoreBtn{
  position:absolute;left:8px;top:8px;z-index:6;
  border:none;border-radius:10px;background:transparent;color:#e6eef6;
  padding:8px 10px;min-height:36px;cursor:pointer;font-weight:700;
  border:1px solid rgba(255,255,255,.2)
}
#resetScoreBtn:hover{background:rgba(255,255,255,.08)}
.table{position:relative;flex:1;display:grid;grid-template-columns:1fr auto 1fr;grid-template-rows:1fr auto 1fr;height:100%;gap:6px}
.player{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:4px}
.name{font-weight:800;letter-spacing:.5px}
.score{font-size:12px;opacity:.9;background:#0d2535;border:1px solid rgba(255,255,255,.16);padding:2px 6px;border-radius:999px}
.player:not(#p-bottom) .hand{display:none}
.hand{display:flex;gap:var(--gap);max-width:96vw;overflow-x:auto;padding:2px;touch-action:pan-x}
#hand-bottom.two-rows{flex-wrap:wrap;row-gap:6px;justify-content:center;overflow-x:hidden}
#hand-bottom.two-rows .card{
  width:var(--card-w-2);height:calc(var(--card-w-2)*1.42);min-width:var(--card-w-2);
}
.card{
  width:var(--card-w);height:var(--card-h);min-width:var(--card-w);
  background:#fff;border-radius:10px;border:2px solid #cfd8dc;color:#0e141a;
  display:flex;align-items:center;justify-content:center;font-weight:800;font-size:18px;
  transition:transform .18s, border-color .18s, box-shadow .18s
}
.card.♥,.card.♦{color:#d11}
.selected{transform:translateY(-12px);border-color:#ffd866;box-shadow:0 6px 14px rgba(255,216,102,.4)}
.dim{opacity:.5;pointer-events:none}
#centerPanel{
  grid-column:2;grid-row:2;
  width:min(92vw, 980px);
  background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  border:1px solid rgba(255,255,255,.14);
  border-radius:16px;padding:10px 14px;backdrop-filter:blur(6px);
  display:flex;flex-direction:column;align-items:center;gap:6px
}
#info{font-size:14px;opacity:.9}
#last{font-size:13px;opacity:.75;min-height:18px}
#pile{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
.pile-card{width:var(--pile-w);height:var(--pile-h);background:#fff;border-radius:10px;border:2px solid #cfd8dc;display:flex;align-items:center;justify-content:center;
  font-weight:800;font-size:14px}
.pile-card.♥,.pile-card.♦{color:#d11}
#logCenter{
  width:100%;max-width:920px;height:140px;overflow-y:auto;border:1px dashed rgba(255,255,255,.18);border-radius:12px;
  padding:8px;background:rgba(0,0,0,.18);font-size:12px;display:flex;flex-direction:column;
}
.log-line{display:flex;align-items:center;gap:8px;margin:3px 0}
.log-who{opacity:.95;font-weight:800;min-width:60px;text-align:right}
.log-kind{opacity:.8}
.log-cards{display:flex;gap:4px;flex-wrap:wrap}
.log-card{width:28px;height:38px;background:#fff;border:2px solid #cfd8dc;border-radius:6px;display:flex;align-items:center;justify-content:center;font-weight:800;color:#0e141a}
.log-card.♥,.log-card.♦{color:#d11}
.actionRow{grid-column:2;display:flex;gap:10px;justify-content:center;margin-top:4px;flex-wrap:wrap}
#p-top{grid-column:2;grid-row:1}
#p-left{grid-column:1;grid-row:2}
#p-right{grid-column:3;grid-row:2}
#p-bottom{grid-column:2;grid-row:3}
#seriesOverlay{
  position:fixed;inset:0;background:rgba(0,0,0,.65);backdrop-filter:blur(4px);
  display:none;align-items:center;justify-content:center;z-index:20
}
#seriesCard{
  width:min(92vw,600px);background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
  border:1px solid rgba(255,255,255,.18);border-radius:16px;padding:16px
}
#seriesCard h2{margin:0 0 10px;font-size:20px;letter-spacing:.6px}
.rank-list{margin:8px 0 12px;padding:0;list-style:none}
.rank-item{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-radius:10px;background:rgba(0,0,0,.22);border:1px solid rgba(255,255,255,.12);margin-bottom:8px}
.rank-item .who{font-weight:800}
.rank-item .pts{opacity:.95}
#roundOverlay{
  position:fixed;inset:0;background:rgba(0,0,0,.65);backdrop-filter:blur(4px);
  display:none;align-items:center;justify-content:center;z-index:18
}
#roundCard{
  width:min(92vw,640px);background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
  border:1px solid rgba(255,255,255,.18);border-radius:16px;padding:16px
}
#roundCard h2{margin:0 0 6px;font-size:20px}
#roundWinner{opacity:.95;margin-bottom:8px}
.pList{list-style:none;margin:0;padding:0}
.pItem{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:10px;background:rgba(0,0,0,.22);border:1px solid rgba(255,255,255,.12);margin-bottom:8px}
.pName{font-weight:800}
.pExplain{opacity:.85;font-size:12px}
.pRight{display:flex;gap:12px;align-items:center}
.pScore{font-weight:800}
#hintOverlay{
  position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;
  align-items:center;justify-content:center;z-index:30;padding:10px
}
#hintPanel{
  width:min(92vw,860px);max-height:70vh;overflow:auto;
  background:#101a24;border:1px solid rgba(255,255,255,.15);border-radius:14px;padding:12px
}
#hintPanel h3{margin:0 0 8px}
.filter{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px}
.chip{padding:6px 10px;border-radius:999px;background:#20303a;border:1px solid #3a5767;font-size:13px;cursor:pointer}
.chip.active{background:#3a5a70;border-color:#5d8ea8}
.combo-wrap{display:flex;flex-wrap:wrap;gap:6px}
.combo{padding:6px 8px;background:#20303a;border:1px solid #3a5767;border-radius:8px;font-size:14px;cursor:pointer}
.combo .tags{font-size:11px;opacity:.75;margin-left:6px}
/* 錯誤提示層 */
#errorOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.65);z-index:50}
#errorCard{width:min(92vw,720px);background:#1a2633;border:1px solid rgba(255,255,255,.2);border-radius:12px;padding:12px}
#errorCard h3{margin:0 0 8px}
#errorMsg{white-space:pre-wrap;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;background:#0e1620;padding:10px;border-radius:8px;max-height:40vh;overflow:auto}
@media (max-width: 820px){
  :root{--card-w:46px;--card-h:66px;--gap:4px;--pile-w:36px;--pile-h:50px}
  #centerPanel{width:82vw}
  #logCenter{height:18vh}
  #hintPanel{width:94vw;max-height:75vh}
}
</style>
</head>
<body>
<div id="stage">
  <div class="topbar">
    <h1>大老二</h1>
  </div>

  <div class="table">
    <button id="resetScoreBtn">重置分數(10000)</button>

    <div id="p-top" class="player"><div class="name" id="name-top"></div><div class="score" id="score-top">10000 分</div><div class="hand" id="hand-top"></div><div class="count" id="cnt-top"></div></div>
    <div id="p-left" class="player"><div class="name" id="name-left"></div><div class="score" id="score-left">10000 分</div><div class="hand" id="hand-left"></div><div class="count" id="cnt-left"></div></div>
    <div id="centerPanel">
      <div id="info">載入中…</div>
      <div id="last"></div>
      <div id="pile"></div>
      <div id="logCenter" aria-label="戰況（新到舊由上往下）"></div>
      <div class="actionRow">
        <button id="playBtn" disabled>出牌</button>
        <button id="passBtn" disabled>PASS</button>
        <button class="btn-ghost" id="hintBtn">提示</button>
        <button class="btn-ghost" id="dealBtn">重發</button>
      </div>
    </div>
    <div id="p-right" class="player"><div class="name" id="name-right"></div><div class="score" id="score-right">10000 分</div><div class="hand" id="hand-right"></div><div class="count" id="cnt-right"></div></div>
    <div id="p-bottom" class="player">
      <div class="name" id="name-bottom">你</div>
      <div class="score" id="score-bottom">10000 分</div>
      <div class="hand" id="hand-bottom"></div>
      <div class="count" id="cnt-bottom"></div>
    </div>
  </div>
</div>

<!-- 單局結算 -->
<div id="roundOverlay" role="dialog" aria-modal="true">
  <div id="roundCard">
    <h2>本局結算</h2>
    <div id="roundWinner"></div>
    <ul class="pList" id="roundList"></ul>
    <div style="display:flex;gap:10px;justify-content:center;margin-top:6px">
      <button id="roundContinueBtn">繼續</button>
      <button class="btn-ghost" id="roundCloseBtn">關閉</button>
    </div>
  </div>
</div>

<!-- 系列戰結算 -->
<div id="seriesOverlay" role="dialog" aria-modal="true">
  <div id="seriesCard">
    <h2>系列戰結算</h2>
    <ul class="rank-list" id="rankList"></ul>
    <div style="display:flex;gap:10px;justify-content:center">
      <button id="restartSeriesBtn">重新開新系列（分數重置 10000）</button>
      <button class="btn-ghost" id="closeSeriesBtn">關閉</button>
    </div>
  </div>
</div>

<!-- 提示面板 -->
<div id="hintOverlay">
  <div id="hintPanel">
    <h3>可出組合</h3>
    <div class="filter" id="filterRow"></div>
    <div class="combo-wrap" id="comboList"></div>
  </div>
</div>

<!-- 錯誤提示 -->
<div id="errorOverlay">
  <div id="errorCard">
    <h3>⚠️ 腳本發生錯誤</h3>
    <div id="errorMsg"></div>
    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:8px">
      <button id="errClose">關閉</button>
      <button class="btn-ghost" id="errReload">重新整理</button>
    </div>
  </div>
</div>

<script>
"use strict";
/* ====== 全域錯誤攔截（避免無法遊戲） ====== */
const errOv = document.getElementById('errorOverlay');
const errMsg = document.getElementById('errorMsg');
const showErr = (msg) => { errMsg.textContent = msg; errOv.style.display='flex'; };
window.onerror = function(message, source, lineno, colno, error){
  const m = (message||'')+'\\n'+(error&&error.stack?error.stack:('at '+source+':'+lineno+':'+colno));
  showErr(m);
};
window.onunhandledrejection = function(e){
  showErr('Unhandled Promise Rejection: '+ (e.reason && e.reason.stack ? e.reason.stack : e.reason));
};
document.getElementById('errClose').onclick=()=>errOv.style.display='none';
document.getElementById('errReload').onclick=()=>location.reload();

/* ====== 資料結構 ====== */
const SUITS=['♣','♦','♥','♠'],RANKS=['3','4','5','6','7','8','9','10','J','Q','K','A','2'];
const suitOrder={'♣':0,'♦':1,'♥':2,'♠':3};
const rIdx=r=>RANKS.indexOf(r);
const compareCard=(a,b)=>(rIdx(a.rank)-rIdx(b.rank))||(suitOrder[a.suit]-suitOrder[b.suit]);
let deck=[],players=[[],[],[],[]],turn=0,currentPlay=null,lastWinner=-1,firstTrick=true,names=[],scores=[10000,10000,10000,10000];

const $ = s => document.querySelector(s);
const logBox = $('#logCenter');
const info = t => $('#info').innerText=t;
const setLast = t => $('#last').innerText=t||'';

function logAppendPlay(who,cards,kind){
  const line = document.createElement('div'); line.className='log-line';
  const ww = document.createElement('div'); ww.className='log-who'; ww.textContent=who;
  const kk = document.createElement('div'); kk.className='log-kind'; kk.textContent='（'+kind+'）';
  const cc = document.createElement('div'); cc.className='log-cards';
  cards.forEach(c=>{ const d=document.createElement('div'); d.className='log-card '+c.suit; d.textContent=c.suit+c.rank; cc.appendChild(d); });
  line.appendChild(ww); line.appendChild(kk); line.appendChild(cc);
  logBox.appendChild(line); logBox.scrollTop = logBox.scrollHeight;
}
function logAppendText(t){
  const line = document.createElement('div'); line.className='log-line';
  const ww = document.createElement('div'); ww.className='log-who'; ww.textContent='';
  const kk = document.createElement('div'); kk.className='log-kind'; kk.textContent=t;
  line.appendChild(ww); line.appendChild(kk); logBox.appendChild(line); logBox.scrollTop = logBox.scrollHeight;
}

/* 修正隨機中文名：2~3 字，避免索引錯誤 */
function randName(){
  const surn="王李張陳林吳黃蔡楊許鄭何郭羅高胡蕭潘江鍾曾賴呂孫魏葉阮邱彭顏謝宋唐馮邵韓曹邢顧";
  const giv ="凱宇家豪志偉冠廷建宏志豪俊傑明哲冠霖俊宇承翰柏宇宗憲怡君欣怡雅婷雅雯佳蓉佩珊惠雯志玲美玲智恩梓萱昕妤宥蓁承恩承恩承翰予婕宜庭語彤語婕";
  const pick=(pool)=>pool[Math.floor(Math.random()*pool.length)];
  const two = pick(giv)+pick(giv);
  const three = pick(giv)+pick(giv)+pick(giv);
  return pick(surn) + (Math.random()<0.5?two:three);
}

function saveScores(){ try{ localStorage.setItem('big2_scores', JSON.stringify(scores)); }catch(e){} }
function loadScores(){
  try{
    const s = JSON.parse(localStorage.getItem('big2_scores'));
    if(Array.isArray(s) && s.length===4) scores = s;
  }catch(e){}
  updateScoreUI();
}
function updateScoreUI(){
  ['bottom','right','top','left'].forEach((pos,i)=>{ $('#score-'+pos).innerText = (scores[i]||0)+' 分'; });
}

/* ====== 牌組處理 ====== */
function buildDeck(){ deck=[]; for(const s of SUITS) for(const r of RANKS) deck.push({suit:s,rank:r}); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function findStart(){ for(let i=0;i<4;i++) if(players[i].some(c=>c.rank==='3'&&c.suit==='♣')) return i; return 0; }

function render(){
  const ids=['hand-bottom','hand-right','hand-top','hand-left'];
  ids.forEach((id,i)=>{
    const area = document.getElementById(id); area.innerHTML='';
    players[i].forEach((c,idx)=>{
      if(i===0){
        const d=document.createElement('div');
        d.className=`card ${c.suit}`; d.textContent=c.suit+c.rank; d.dataset.idx=idx;
        area.appendChild(d);
      } // 他家不顯示牌面
    });
  });
  ['bottom','right','top','left'].forEach((pos,i)=>$('#cnt-'+pos).innerText=players[i].length);
  adjustTwoRows();
}

function toggleCardSel(target){
  const card=target.closest('.card'); if(!card || turn!==0) return;
  card.classList.toggle('selected');
}
$('#hand-bottom').addEventListener('pointerdown', e=>toggleCardSel(e.target), {passive:true});
$('#hand-bottom').addEventListener('click', e=>toggleCardSel(e.target)); // 兼容

function updateTurnUI(){
  const mine = (turn===0);
  const canPass = mine && !!currentPlay;
  const playEl=document.getElementById('playBtn'), passEl=document.getElementById('passBtn');
  if(playEl) playEl.disabled = !mine;
  if(passEl) passEl.disabled = !canPass;
  info(mine ? (firstTrick? '輪到你（首攻需含 ♣3；首攻不可 PASS）' : (currentPlay?'輪到你（可跟牌或 PASS）':'你拿到出牌權（不可 PASS）')) : `等待 ${names[turn]} 出牌…`);
}

/* ====== 兩排手牌（直式且溢出時） ====== */
function isPortrait(){ return window.innerHeight > window.innerWidth; }
function adjustTwoRows(){
  const hand = document.getElementById('hand-bottom');
  hand.classList.remove('two-rows');
  if(!isPortrait()) return;
  const n = players[0].length;
  if(n<=7) return;
  const avail = Math.floor(window.innerWidth * 0.94);
  const rootStyles = getComputedStyle(document.documentElement);
  const gap = parseInt(rootStyles.getPropertyValue('--gap')) || 6;
  const cardW = parseInt(rootStyles.getPropertyValue('--card-w')) || 56;
  const oneRowWidth = n*cardW + (n-1)*gap;
  if(oneRowWidth <= avail) return;
  const cols = Math.ceil(n/2);
  const w2 = Math.max(40, Math.min(72, Math.floor((avail - (cols-1)*gap)/cols)));
  hand.style.setProperty('--card-w-2', w2 + 'px');
  hand.classList.add('two-rows');
}
window.addEventListener('resize', adjustTwoRows);

/* ====== 遊戲流程 ====== */
function deal(){
  names=['你',randName(),randName(),randName()];
  $('#name-right').innerText=names[1];
  $('#name-top').innerText=names[2];
  $('#name-left').innerText=names[3];
  $('#pile').innerHTML=''; logBox.innerHTML=''; setLast('');
  buildDeck(); shuffle(deck);
  players=[[],[],[],[]];
  for(let i=0;i<52;i++) players[i%4].push(deck[i]);
  players.forEach(p=>p.sort(compareCard));
  currentPlay=null; lastWinner=-1; firstTrick=true; turn=findStart();
  render(); updateTurnUI();
  info(`持有 ♣3 的玩家（${names[turn]}）先攻`);
  if(turn!==0) setTimeout(aiPlay,500);
}

/* ====== 手型分析 ====== */
function isConsec(s){ for(let i=1;i<s.length;i++) if(rIdx(s[i].rank)!==rIdx(s[i-1].rank)+1) return false; return true; }
function analyze(cs){
  const n=cs.length, s=[...cs].sort(compareCard);
  if(n===1) return {ok:true,kind:'單張',high:s[0]};
  if(n===2 && s[0].rank===s[1].rank) return {ok:true,kind:'對子',high:s[1]};
  if(n===3 && s.every(c=>c.rank===s[0].rank)) return {ok:true,kind:'三條',high:s[2]};
  if(n===4 && s.every(c=>c.rank===s[0].rank)) return {ok:true,kind:'鐵支',high:s[3]};
  if(n===5){
    const rc={}; s.forEach(c=>rc[c.rank]=(rc[c.rank]||0)+1);
    const vals=Object.values(rc).sort((a,b)=>b-a);
    const sameSuit=s.every(c=>c.suit===s[0].suit);
    const consec=isConsec(s);
    if(sameSuit&&consec) return {ok:true,kind:'同花順',high:s[4]};
    if(vals[0]===3&&vals[1]===2){
      const trip=Object.keys(rc).find(r=>rc[r]===3);
      const high=s.filter(c=>c.rank===trip).slice(-1)[0];
      return {ok:true,kind:'葫蘆',high};
    }
    if(consec) return {ok:true,kind:'順子',high:s[4]};
  }
  return {ok:false};
}
const strength={'單張':1,'對子':2,'三條':3,'順子':4,'葫蘆':5,'鐵支':6,'同花順':7};

/* ====== 所有可用組合 ====== */
function combos(hand){
  const res=[],map={};
  hand.forEach(c=>(map[c.rank]=map[c.rank]||[]).push(c));
  hand.forEach(c=>res.push([c]));
  for(const r in map){
    const a=map[r];
    if(a.length>=2) for(let i=0;i<a.length;i++) for(let j=i+1;j<a.length;j++) res.push([a[i],a[j]]);
    if(a.length>=3) for(let i=0;i<a.length;i++) for(let j=i+1;j<a.length;j++) for(let k=j+1;k<a.length;k++) res.push([a[i],a[j],a[k]]);
    if(a.length===4) res.push(a.slice());
  }
  const n=hand.length;
  if(n>=5){
    for(let a=0;a<n-4;a++) for(let b=a+1;b<n-3;b++) for(let c=b+1;c<n-2;c++) for(let d=c+1;d<n-1;d++) for(let e=d+1;e<n;e++){
      const pack=[hand[a],hand[b],hand[c],hand[d],hand[e]];
      const an=analyze(pack);
      if(an.ok && (an.kind==='順子'||an.kind==='葫蘆'||an.kind==='同花順')) res.push(pack);
    }
  }
  res.sort((x,y)=>{
    const A=analyze(x),B=analyze(y);
    if(strength[A.kind]!==strength[B.kind]) return strength[A.kind]-strength[B.kind];
    const r=rIdx(A.high.rank)-rIdx(B.high.rank);
    return r!==0?r:(suitOrder[A.high.suit]-suitOrder[B.high.suit]);
  });
  return res;
}

/* ====== AI（會出多張與五張） ====== */
function pickLeaderCombo(all, enemyAlmostWin){
  const prefer = enemyAlmostWin
    ? ['同花順','鐵支','葫蘆','順子','三條','對子','單張']
    : ['順子','葫蘆','三條','對子','單張'];
  for(const k of prefer){
    const cands = all.filter(c=>analyze(c).kind===k);
    if(cands.length) return cands[0];
  }
  return all[0]||null;
}
function pickResponseCombo(options, currentPlay){
  const needKind = analyze(currentPlay).kind;
  const same = options.filter(c=>analyze(c).kind===needKind);
  if(same.length) return same[0];
  const bombs = options.filter(c=>['鐵支','同花順'].includes(analyze(c).kind));
  if(bombs.length) return bombs[0];
  return options[0]||null;
}

function aiPlay(){
  const i=turn, hand=players[i];
  const isLeader = !currentPlay || turn===lastWinner;
  const all=combos(hand);
  const enemyAlmostWin = players.some((p,idx)=>idx!==i && p.length<=2);
  let options=[];
  if(!currentPlay){
    options = firstTrick ? all.filter(c=>c.some(x=>x.rank==='3'&&x.suit==='♣')) : all;
    const choice = pickLeaderCombo(options, enemyAlmostWin);
    if(choice) play(i,choice); else { info(`${names[i]} PASS`); logAppendText(`${names[i]} PASS`); next(); }
    return;
  }else{
    options = all.filter(c=>canBeat(c,currentPlay));
    if(options.length){
      const choice = pickResponseCombo(options, currentPlay);
      play(i,choice); return;
    }
    if(isLeader){
      const nonSingles = all.filter(c=>analyze(c).kind!=='單張');
      play(i, (nonSingles[0]||all[0]) );
    }else{
      info(`${names[i]} PASS`); logAppendText(`${names[i]} PASS`); next();
    }
  }
}

/* ====== 出牌與回合 ====== */
function toStr(cards){ return cards.map(c=>c.suit+c.rank).join(' '); }
function renderPile(playerName,cards,kind){
  const pile=$('#pile'); pile.innerHTML='';
  const head=document.createElement('div'); head.style.fontSize='12px'; head.style.opacity=.9; head.textContent = `${playerName}（${kind}）`;
  pile.appendChild(head);
  const row=document.createElement('div'); row.style.display='flex'; row.style.gap='8px'; row.style.flexWrap='wrap'; row.style.justifyContent='center';
  cards.forEach(c=>{ const d=document.createElement('div'); d.className='pile-card '+c.suit; d.textContent=c.suit+c.rank; row.appendChild(d); });
  pile.appendChild(row);
}
function play(i,cards){
  // 安全移除手牌（避免索引錯誤）：逐張尋找最先匹配者
  cards.forEach(sel=>{
    const idx=players[i].findIndex(p=>p.rank===sel.rank&&p.suit===sel.suit);
    if(idx>-1) players[i].splice(idx,1);
  });
  render();
  const an=analyze(cards);
  currentPlay=cards; lastWinner=i; firstTrick=false;
  setLast(`${names[i]}：${toStr(cards)}（${an.kind}）`);
  logAppendPlay(names[i],cards,an.kind);
  renderPile(names[i],cards,an.kind);
  if(players[i].length===0){ endRound(i); return; }
  next();
}
function next(){
  turn=(turn+1)%4;
  if(players[turn].length===0) turn=(turn+1)%4; // 已脫手者略過
  if(turn===lastWinner){ currentPlay=null; setLast(`${names[turn]} 重新出牌`); $('#pile').innerHTML=''; }
  updateTurnUI();
  if(turn!==0) setTimeout(aiPlay,500);
}
function selected(){ return [...document.querySelectorAll('#hand-bottom .card.selected')].map(el=>players[0][parseInt(el.dataset.idx,10)]); }
function onPlay(){
  const mine = (turn===0);
  if(!mine) return;
  const cs=selected();
  if(!cs.length){ info('請先選牌'); return; }
  const an=analyze(cs);
  if(!an.ok){ info('不合法組合'); return; }
  if(firstTrick && !cs.some(c=>c.rank==='3'&&c.suit==='♣')){ info('首攻必含 ♣3'); return; }
  if(currentPlay && !canBeat(cs,currentPlay)){ info('比不過前家'); return; }
  play(0,cs);
}
function onPass(){
  const mine = (turn===0);
  if(!mine) return;
  if(!currentPlay){ info('首攻不可 PASS'); return; }
  info('你 PASS'); logAppendText('你 PASS'); next();
}

/* ====== 計分（贏家吃分）與結算 ====== */
function hasFourOfKind(hand){
  const rc={}; hand.forEach(c=>rc[c.rank]=(rc[c.rank]||0)+1);
  return Object.values(rc).some(v=>v===4);
}
function hasStraightFlush(hand){
  const bySuit={'♣':[], '♦':[], '♥':[], '♠':[]};
  hand.forEach(c=>bySuit[c.suit].push(c));
  for(const s in bySuit){
    const arr=bySuit[s].sort(compareCard);
    for(let i=0;i<=arr.length-5;i++){
      const slice=arr.slice(i,i+5);
      if(slice.length===5 && slice.every((c,idx)=>idx===0 || rIdx(c.rank)===rIdx(slice[idx-1].rank)+1)) return true;
    }
  }
  return false;
}
let pendingNextAction = null;
function endRound(winnerIdx){
  const detail=[];
  const perPlayer = [];
  let totalGain = 0;
  for(let i=0;i<4;i++){
    if(i===winnerIdx) continue;
    const remain=players[i];
    let pen = remain.length * 10;
    const explains=[];
    explains.push(`剩 ${remain.length} 張 ×10 = ${remain.length*10}`);
    if(remain.length>=8){ pen *= 2; explains.push('≥8 張 ×2'); }
    if(remain.some(c=>c.rank==='2')){ pen *= 2; explains.push('含 2 ×2'); }
    if(hasFourOfKind(remain)){ pen *= 2; explains.push('鐵支 ×2'); }
    if(hasStraightFlush(remain)){ pen *= 2; explains.push('同花順 ×2'); }
    scores[i] -= pen;
    totalGain += pen;
    perPlayer.push({i,name:names[i],delta:-pen,explain:explains.join('、'),score:scores[i]});
    detail.push(`${names[i]} -${pen} 分（${explains.join('、')}）`);
  }
  scores[winnerIdx] += totalGain;
  perPlayer.push({i:winnerIdx,name:names[winnerIdx],delta:+totalGain,explain:`收取其他玩家懲罰總和 +${totalGain} 分`,score:scores[winnerIdx]});

  saveScores(); updateScoreUI();
  logAppendText(`🏁 ${names[winnerIdx]} 脫手，結束本局（贏家 +${totalGain} 分）。`);
  detail.forEach(t=>logAppendText('　• '+t));

  const seriesOver = scores.some(s=>s<=0);
  showRoundOverlay(winnerIdx, perPlayer, seriesOver);
}

function showRoundOverlay(winnerIdx, perPlayer, seriesOver){
  const ov = document.getElementById('roundOverlay');
  const list = document.getElementById('roundList');
  const win = document.getElementById('roundWinner');
  const btn = document.getElementById('roundContinueBtn');
  list.innerHTML='';
  win.textContent = `本局贏家：${names[winnerIdx]}`;

  perPlayer.sort((a,b)=>a.i-b.i).forEach(p=>{
    const li=document.createElement('li'); li.className='pItem';
    const left=document.createElement('div');
    const name=document.createElement('div'); name.className='pName'; name.textContent = p.name + (p.i===0?'（你）':'');
    const explain=document.createElement('div'); explain.className='pExplain'; explain.textContent = p.explain;
    left.appendChild(name); left.appendChild(explain);
    const right=document.createElement('div'); right.className='pRight';
    const delta=document.createElement('div'); delta.className='pScore'; delta.textContent = (p.delta>=0? '+' : '') + p.delta + ' 分';
    const total=document.createElement('div'); total.className='pScore'; total.style.opacity=.85; total.textContent = '現有：'+p.score+' 分';
    right.appendChild(delta); right.appendChild(total);
    li.appendChild(left); li.appendChild(right); list.appendChild(li);
  });

  btn.textContent = seriesOver ? '查看系列戰排名' : '繼續下一局';
  pendingNextAction = seriesOver ? 'series' : 'deal';
  ov.style.display='flex';
}
function hideRoundOverlay(){ document.getElementById('roundOverlay').style.display='none'; }
document.getElementById('roundContinueBtn').onclick=()=>{
  const act = pendingNextAction; pendingNextAction=null;
  hideRoundOverlay();
  if(act==='series') showSeriesOverlay(); else deal();
};
document.getElementById('roundCloseBtn').onclick=hideRoundOverlay;

function showSeriesOverlay(){
  const ov = document.getElementById('seriesOverlay');
  const list = document.getElementById('rankList');
  list.innerHTML='';
  const arr = [0,1,2,3].map(i=>({i,name:names[i],score:scores[i]})).sort((a,b)=>b.score-a.score);
  arr.forEach((p,idx)=>{
    const li=document.createElement('li'); li.className='rank-item';
    const medal = idx===0?'🥇':idx===1?'🥈':idx===2?'🥉':'🏁';
    const who=document.createElement('div'); who.className='who'; who.textContent = `${medal} ${p.name}`+(p.i===0?'（你）':'');
    const pts=document.createElement('div'); pts.className='pts'; pts.textContent = `${p.score} 分`;
    li.appendChild(who); li.appendChild(pts); list.appendChild(li);
  });
  ov.style.display='flex';
}
function hideSeriesOverlay(){ document.getElementById('seriesOverlay').style.display='none'; }
document.getElementById('restartSeriesBtn').onclick=()=>{
  scores=[10000,10000,10000,10000]; saveScores(); updateScoreUI(); hideSeriesOverlay(); deal();
};
document.getElementById('closeSeriesBtn').onclick=hideSeriesOverlay;

/* ====== 提示（類型篩選） ====== */
const HINT_TYPES=['單張','對子','三條','順子','葫蘆','鐵支','同花順'];
const hintOverlay=$('#hintOverlay'), filterRow=$('#filterRow'), comboList=$('#comboList');
let activeType=null;
function legalCombosByType(){
  let arr = combos(players[0]);
  if(firstTrick) arr = arr.filter(c=>c.some(x=>x.rank==='3'&&x.suit==='♣'));
  if(currentPlay) arr = arr.filter(c=>canBeat(c,currentPlay));
  if(activeType) arr = arr.filter(c=>analyze(c).kind===activeType);
  return arr;
}
function openHints(){
  activeType = currentPlay ? analyze(currentPlay).kind : null;
  renderFilterChips(); renderComboList();
  hintOverlay.style.display='flex';
}
function closeHints(){ hintOverlay.style.display='none'; }
hintOverlay.addEventListener('click', e=>{ if(e.target===hintOverlay) closeHints(); });
function renderFilterChips(){
  filterRow.innerHTML='';
  HINT_TYPES.forEach(t=>{
    const chip=document.createElement('div'); chip.className='chip'+(activeType===t?' active':'');
    chip.textContent=t; chip.onclick=()=>{ activeType = (activeType===t? null : t); renderFilterChips(); renderComboList(); };
    filterRow.appendChild(chip);
  });
}
function renderComboList(){
  comboList.innerHTML='';
  const arr=legalCombosByType();
  if(arr.length===0){ comboList.textContent='（目前沒有可出的組合）'; return; }
  arr.slice(0,200).forEach(c=>{
    const an=analyze(c);
    const div=document.createElement('div'); div.className='combo'; div.textContent=toStr(c);
    const tag=document.createElement('span'); tag.className='tags'; tag.textContent=an.kind; div.appendChild(tag);
    div.onclick=()=>{
      document.querySelectorAll('#hand-bottom .card').forEach(el=>el.classList.remove('selected'));
      const hb=[...document.querySelectorAll('#hand-bottom .card')];
      const need=c.map(x=>x.suit+x.rank);
      hb.forEach(el=>{ const key=el.textContent; const idx=need.indexOf(key); if(idx>-1){ el.classList.add('selected'); need.splice(idx,1); } });
      closeHints();
    };
    comboList.appendChild(div);
  });
}

/* ====== 綁定 ====== */
document.getElementById('playBtn').onclick=onPlay;
document.getElementById('passBtn').onclick=onPass;
document.getElementById('dealBtn').onclick=deal;
document.getElementById('hintBtn').onclick=openHints;
document.getElementById('resetScoreBtn').onclick=()=>{ scores=[10000,10000,10000,10000]; saveScores(); updateScoreUI(); logAppendText('🔄 分數已重置為 10000'); };

/* ====== 啟動 ====== */
loadScores();
deal();
</script>
</body>
</html>
